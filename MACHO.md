## Mach-O文件和进程的映像(image)
iOS系统生成的可执行程序或者动态库文件的存储布局格式被称之为`Mach-O`格式。文件中存放着程序的代码和数据，而程序运行时系统会为其建立一个`进程`，以及`分配虚拟内存空间`。同时会把程序文件中的内容加载到虚拟内存地址空间中去，这种加载的方法一般采用`内存映射文件`的技术来实现。所谓的`映像`可以理解为将一个程序文件的内容加载到进程虚拟内存中的内容，**`也就是说进程的映像就是程序磁盘文件在内存中的一个副本`**。 一般来说一个进程中映像的内容和内存布局结构会和程序文件的内容以及存储布局结构一致，映像的首地址是一个 `mach_header`的结构体。映像中内容的排列布局和程序文件都是以段(Segment)为单位进行排列的。但是有一些情况映像的内存布局和内容可能会和程序文件的内存布局和内容不一致：

1. 映像中的`数据段`(`__DATA`)部分，因为数据段部分大多是可以被读写访问的，也就是说可以在运行时被修改，或者某些信息会进行rebase处理。因此数据段不能被进程之间共享，而是每个进程单独维护一份。当然为了效率和性能系统会采用一种称之为Copy on write的技术来实现单独副本的拷贝的。通常只有不可变的代码段部分才会是内存和文件中的内容保持一致，并且多进程共享。一个很常见的例子就是进程中加载的动态库和框架中的代码段部分通常都是所有进程共享。
2. 即使是代码段也有可能映像中的内容和程序文件中的内容不一致。有一些映像中的某些段的内容会是系统中缓存的段，而不是程序文件对应的段。一个很有代表性的例子就是CoreLocation这个库，当这个库被加载时你就会发现其映像中的有一些代码段的内容其实是系统缓存的内容而不是程序文件中的内容。

所以说程序文件和程序被加载后在内存中映像之间并不是一一对应的。程序文件和映像之间的关系就如程序和进程之间的关系是一样的。在程序运行后对其在进程中所有的Mach-O数据结构的访问都是基于映像而不是基于程序文件的。

## Slide机制
构建一个程序时为了方便计算和处理会为这个程序设定一个默认在内存中加载的基地址。这样在程序中所有涉及到地址存储的代码中的地址变量都是以这个基地址为标准的。比如我们在代码中有变量保存一个函数的地址或者在rumtime中的OC类的方法结构体:struct method_t中的imp保存的函数的地址等等。正常情况下如果我们的程序加载时也是按照程序中指定的基地址加载到虚拟内存中对应的地址时则一切都正常而且也不需要做任何的改变。但实际情况则不同：

1. 任何一个库或者可执行程序在构建时都会指定一个加载的基地址，但是却无法保证这个基地址的唯一性。和无法保证程序映像的地址区间不产生重叠。因此有可能出现多个库加载到内存时的重叠覆盖的情况。
2. iOS系统为保证的应用安全采用了一种称之为`ASLR`(Address Space Layout Randomization)的技术。这种技术会使得每个程序或者库每次运行加载到内存中时的基地址都不是固定而是随机的，这种机制会增加黑客的破解难度。

上面的两种情况表明一个程序或者库加载到内存时的真实的基地址和程序构建时指定的基地址是不一样的。`系统会为可执行程序和每个库选择不重叠的区域进行加载`。但是这样就会出现在程序中所有以构建时基地址为标准的那些地址指针出现访问异常，因为这些地址值并不是真实在内存中的地址值。
为了解决这个问题系统会在构建的程序或库中添加一个特殊的load command命令：`LC_DYLD_INFO`或者`LC_DYLD_INFO_ONLY`。这部分信息用来记录所有需要进行地址调整的位置。这样当程序被加载到内存时，加载器就会将需要调整的地址分别进行调整处理，以便转化为真实的内存地址。这个过程称之为`基地址重定向`(rebase)。
假设程序构建时指定的基地址为A，程序中某处保存的一个函数指针地址为x，而程序被加载到内存时的真实基地址为B。也就是说真实的基地址和构建时的基地址的偏移差就是B-A。我们称这个偏移差值为Slide值。因此真实的地址x被调整后应该是： x + (B - A)了。
一个程序在构建时的基地址值可以在程序的第一个名为__TEXT的代码段描述结构体struct segment_command中的vmaddr数据成员中获取，而程序被加载后的得到的映像的mach-o头部结构体struct mach_header指针则是映像被加载的真实的基地址，因此：
映像的Slide值 = 映像的mach_header结构体指针 -  映像的第一个__TEXT代码段描述结构体struct segmeng_command中的vmaddr数据成员的值。
当然系统也提供了接口API来获取可执行程序或者库的映像的Slide值。这个将会在下面介绍。

## 进程映像(Image)操作API
对映像进行操作的API都在<mach-o/dyld.h>中声明。你可以import这个头文件来使用里面定义的函数。下面我会分别介绍这些函数。
1. 获取当前进程中加载的映像的数量
```
//函数返回当前进程中加载的映像的数量
uint32_t  _dyld_image_count(void) 
```
2. 获取某个映像的mach-o头部信息结构体指针
```
const struct mach_header*   _dyld_get_image_header(uint32_t image_index) 
```
函数的入参为映像在进程当中的索引号，函数返回的值是一个映像的mach-o头部信息struct mach_header结构体指针，如果是64位系统则返回的是struct mach_header_64结构体指针。你可以通过这个函数返回的映像的头部结构体来遍历和访问映像中的所有信息和数据。

**`一个映像的头部信息结构体指针其实就是映像在内存中加载的基地址。`**

**`一般情况下索引为0的映像是DYLD库的映像，而索引为1的映像就是当前进程的可执行程序映像。但是在lldbx执行image list操作时，输出的索引为0的是当前可执行程序映像，而索引为1的映像是DYLD库的映像，是反过来的。`**

3. 获取进程中某个映像加载的Slide值
```
intptr_t   _dyld_get_image_vmaddr_slide(uint32_t image_index) 
```

函数的入参为映像在进程当中的索引号，函数的返回值是映像加载的Slide值。关于Slide值的介绍已经在上面有详细说明。在mach-o格式程序中的结构体描述信息中凡是涉及到指针字段都应该加上这个值才是真实的内存地址。

4. 获取进程中某个映像的名称
```
const char*  _dyld_get_image_name(uint32_t image_index)
```
函数的入参为映像在进程当中的索引号，函数的返回值是映像对应库的全路径名称，返回的字符串我们不能修改也不必去销毁它。

5. 注册映像加载和卸载的回调通知函数
```
void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))
void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))
```
如果你通过函数_dyld_register_func_for_add_image注册了一个映像被加载时的回调函数时，那么每当后续一个新的映像被加载但未初始化前就会调用注册的回调函数，回调函数的两个入参分别表示加载的映像的头结构和对应的Slide值。如果在调用_dyld_register_func_for_add_image时系统已经加载了某些映像，则会分别对这些加载完毕的每个映像调用注册的回调函数。
如果你通过函数_dyld_register_func_for_remove_image注册了一个映像被卸载时的回调函数时，那么每当一个映像被卸载前都会调用注册的回调函数，回调函数的两个入参分别表示卸载的映像的头结构和对应的Slide值。
这两个函数的作用通常用来做程序加载映像的监控以及一些统计处理。

6. 获取某个库链接时和运行时的版本号
```
//获取库运行时的版本号
int32_t NSVersionOfRunTimeLibrary(const char* libraryName)
//获取库链接时的版本号
int32_t NSVersionOfLinkTimeLibrary(const char* libraryName)
```
我们在XCODE工程中链接一些系统动态库时，有时候会选择某个具体版本的动态库，但是有些操作系统可能不一定会提供对应版本的动态库，这样就会导致程序运行时加载的动态库版本和链接时指定的动态库的版本不一致。还有一种场景就是工程中并没有链接对应的动态库，但是因为其他库会链接对应的动态库，就会出现虽然没有直接链接对应的动态库但是还是会加载对应的动态库的情况。
因此系统提供了这两个API可以获取某个动态库链接和加载运行时的版本号。这两个函数的入参都是动态库的名称，这个名称是不带路径和扩展名以及不带lib前缀的库名称。函数返回库对应的版本号，如果库不存在或者没有被加载或者没有被链接则返回-1。比如下面的代码：
//这里的名称c++其实是指的libc++.dylib这个库。
uint32_t v1 =  NSVersionOfRunTimeLibrary("c++");
uint32_t v2 =  NSVersionOfLinkTimeLibrary("c++");

如果我们的程序并没有显示的链接libc++.dylib则后者函数会返回-1。而前者则一般都会返回一个对应的libc++的版本号。
这两个函数的主要用来做一些库分析和运行监测等功能，比如可以检测某个库是否是一个在运行时被加载而不是显示链接进来的动态库。

7. 获取当前进程可执行程序的路径文件名
int _NSGetExecutablePath(char* buf, uint32_t* bufsize)

函数的入参buf和bufsize指明保存可执行文件路径名的缓存和缓存的尺寸，其中的bufsize是要指明缓存的尺寸，并且会输出可执行文件路径名称的真实尺寸。如果函数调用返回正确则返回0，否则返回-1。就比如下面的例子：
char buf[256];
uint32_t bufsize = sizeof(buf)/sizeof(char);
_NSGetExecutablePath(buf, &bufsize);


8. 注册当前线程结束时的回调函数
```
void _tlv_atexit(void (*termFunc)(void* objAddr), void* objAddr)
```

有时候我们想监控线程的结束事件，那么就可以用这个函数来实现。这个函数用来监控当前线程的结束，当线程结束或者终止时就会调用注册的回调函数，_tlv_atexit函数有两个参数：第一个是一个回调函数指针，第二个是一个扩展参数，作为回调函数的入参来使用。




