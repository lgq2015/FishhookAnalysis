## Mach-O文件和进程的映像(image)
iOS系统生成的可执行程序或者动态库文件的存储布局格式被称之为`Mach-O`格式。文件中存放着程序的代码和数据，而程序运行时系统会为其建立一个`进程`，以及`分配虚拟内存空间`。同时会把程序文件中的内容加载到虚拟内存地址空间中去，这种加载的方法一般采用`内存映射文件`的技术来实现。所谓的`映像`可以理解为将一个程序文件的内容加载到进程虚拟内存中的内容，**`也就是说进程的映像就是程序磁盘文件在内存中的一个副本`**。 一般来说一个进程中映像的内容和内存布局结构会和程序文件的内容以及存储布局结构一致，映像的首地址是一个 `mach_header`的结构体。映像中内容的排列布局和程序文件都是以段(Segment)为单位进行排列的。但是有一些情况映像的内存布局和内容可能会和程序文件的内存布局和内容不一致：

1. 映像中的`数据段`(`__DATA`)部分，因为数据段部分大多是可以被读写访问的，也就是说可以在运行时被修改，或者某些信息会进行rebase处理。因此数据段不能被进程之间共享，而是每个进程单独维护一份。当然为了效率和性能系统会采用一种称之为Copy on write的技术来实现单独副本的拷贝的。通常只有不可变的代码段部分才会是内存和文件中的内容保持一致，并且多进程共享。一个很常见的例子就是进程中加载的动态库和框架中的代码段部分通常都是所有进程共享。
2. 即使是代码段也有可能映像中的内容和程序文件中的内容不一致。有一些映像中的某些段的内容会是系统中缓存的段，而不是程序文件对应的段。一个很有代表性的例子就是CoreLocation这个库，当这个库被加载时你就会发现其映像中的有一些代码段的内容其实是系统缓存的内容而不是程序文件中的内容。

所以说程序文件和程序被加载后在内存中映像之间并不是一一对应的。程序文件和映像之间的关系就如程序和进程之间的关系是一样的。在程序运行后对其在进程中所有的Mach-O数据结构的访问都是基于映像而不是基于程序文件的。

## Slide机制
构建一个程序时为了方便计算和处理会为这个程序设定一个默认在内存中加载的基地址。这样在程序中所有涉及到地址存储的代码中的地址变量都是以这个基地址为标准的。比如我们在代码中有变量保存一个函数的地址或者在rumtime中的OC类的方法结构体:struct method_t中的imp保存的函数的地址等等。正常情况下如果我们的程序加载时也是按照程序中指定的基地址加载到虚拟内存中对应的地址时则一切都正常而且也不需要做任何的改变。但实际情况则不同：

1. 任何一个库或者可执行程序在构建时都会指定一个加载的基地址，但是却无法保证这个基地址的唯一性。和无法保证程序映像的地址区间不产生重叠。因此有可能出现多个库加载到内存时的重叠覆盖的情况。
2. iOS系统为保证的应用安全采用了一种称之为`ASLR`(Address Space Layout Randomization)的技术。这种技术会使得每个程序或者库每次运行加载到内存中时的基地址都不是固定而是随机的，这种机制会增加黑客的破解难度。

上面的两种情况表明一个程序或者库加载到内存时的真实的基地址和程序构建时指定的基地址是不一样的。`系统会为可执行程序和每个库选择不重叠的区域进行加载`。但是这样就会出现在程序中所有以构建时基地址为标准的那些地址指针出现访问异常，因为这些地址值并不是真实在内存中的地址值。
为了解决这个问题系统会在构建的程序或库中添加一个特殊的load command命令：`LC_DYLD_INFO`或者`LC_DYLD_INFO_ONLY`。这部分信息用来记录所有需要进行地址调整的位置。这样当程序被加载到内存时，加载器就会将需要调整的地址分别进行调整处理，以便转化为真实的内存地址。这个过程称之为`基地址重定向`(rebase)。
假设程序构建时指定的基地址为A，程序中某处保存的一个函数指针地址为x，而程序被加载到内存时的真实基地址为B。也就是说真实的基地址和构建时的基地址的偏移差就是B-A。我们称这个偏移差值为Slide值。因此真实的地址x被调整后应该是： x + (B - A)了。
一个程序在构建时的基地址值可以在程序的第一个名为__TEXT的代码段描述结构体struct segment_command中的vmaddr数据成员中获取，而程序被加载后的得到的映像的mach-o头部结构体struct mach_header指针则是映像被加载的真实的基地址，因此：
映像的Slide值 = 映像的mach_header结构体指针 -  映像的第一个__TEXT代码段描述结构体struct segmeng_command中的vmaddr数据成员的值。
当然系统也提供了接口API来获取可执行程序或者库的映像的Slide值。这个将会在下面介绍。

## 进程映像(Image)操作API
对映像进行操作的API都在<mach-o/dyld.h>中声明。你可以import这个头文件来使用里面定义的函数。下面我会分别介绍这些函数。
1. 获取当前进程中加载的映像的数量
```
//函数返回当前进程中加载的映像的数量
uint32_t  _dyld_image_count(void) 
```
2. 获取某个映像的mach-o头部信息结构体指针
```
const struct mach_header*   _dyld_get_image_header(uint32_t image_index) 
```
函数的入参为映像在进程当中的索引号，函数返回的值是一个映像的mach-o头部信息struct mach_header结构体指针，如果是64位系统则返回的是struct mach_header_64结构体指针。你可以通过这个函数返回的映像的头部结构体来遍历和访问映像中的所有信息和数据。

**`一个映像的头部信息结构体指针其实就是映像在内存中加载的基地址。`**
**`一般情况下索引为0的映像是dyld库的映像，而索引为1的映像就是当前进程的可执行程序映像。`**


